Z-index only works on elements that are not statically positioned. 

It is not possible for a child element to have a lower z-index than its parent. You'd have to make them siblings or use a pseudo elemetn instead. 

URL stands for uniform resource locator. 

When navigating files (e.g. in a relative url), to go up one level, use two dots. 

A root relative link starts from the root folder. It starts with a forward slash. 

JPGs are good for photos. 

GIFs are used for simple animations but have a limited colour palette. 

PNGs are best for icons, logos etc. 

SVGs are vector-based which means they can be scaled to any size without any loss of quality - better than PNGs for responsive pages. 

Right single quotation - &rsquo;
Left double quotation - &ldquo;
Right double quotation - &rdquo;

Inline elements don't affect vertical spacing on a page. 
Inline elements don't accept top or bottom margin. 
If you give top or bottom padding to an inline element, it will flow over elements above and below so as not to affect page's vertical spacing. 
If you have a block element with a margin-bottom and, below that, another block element with margin-top, the smaller margin will collapse. 
To prevent this behavious, you need to put an empty element between them (e.g. empty div with 1px padding-top).
The alternative is to use padding as it doesn't collapse.
But it's probably easier to stick to a top-only or bottom-only rule for margins. 

The text-align property wordk on the content of block elements (so inline elements e.g. text inside a paragraph, images), not the block element itself.
It must be used on the parent element/container. 

Setting margin to auto to center an element only works for block elements. For example, you can't center an image with. But you coud if you changed the display to block. 

Use semantic class names rather than desceiptive ones. For example, instead of .italic use .synopsis. Basically it's so you can change the appearance later and avoid confusion.

This is a descendant selector:
#main span {
}
This is a child selector:
#main > span {
}
The first will target any children, grandchildren etc. THe second will only target direct children.  

Use :last-of-type property to select last child of a type in every container e.g.
p:last-of-type{
margin-bottom: 50px;
}
There is also a corresponding first-of-type proprty. 

ID selectors always override class selectors, even if they're before them in the CSS file. 
The link pseudo class also overrides other classes. 
A class selector will override a type selector, regardless of order. 

Use 'clear: both' when you want an elemtn (e.g. a footer) to not ignore floated elements above (i.e. to appear after them). 
Similarly, adding the 'overflow: hidden' property on a parent element makes it acknowledge the height of the floated elements within. 

If you have a number of flex-items with flex properties (e.g. 1, 1, 1) but you want one or more of them to have fixed widths, you need to assign a width property and also flex: inital which will make it ignore previous flex: 1 rule. 

If you have three flex-items and you want one one one side and the other two together on the other side, you've got 2 options:
1. Group the two items together in a new div, then give the parent 'justify-content: space-between'
2. Have them in the same div (e.g. space between) but give the one in the middle margin-left: auto. This will push it over to the right.

When you add an animation with a class like so:

.event-container {
    width: 50%;
    position: relative;
    padding: 10px 100px;
    top: 30vh;
    margin-bottom: 20vh;
    opacity: 0;
}

.event-container.slide {
    animation: slide 1s ease-out;
}

Make sure you don't leave a space between the element and the class (before the dot)

The main difference betwen inline and inline-block is that the latter allows you to set a width and height. ALso, the top and bottom margins are respected. 

Using certain proprties such as opacity or transform on an element gives it a new stacking context (brings it forward). 

If you want to center an absolutely positioned element, you need to give it these properties:
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
And then you need to give it a fixed width (and/or height)

Margin: 0 auto will not work on absolutely positioned elements (I think because they're no longer block)

When creating CSS animations/transitions, don't use top/left/right/bottom properties - this will results in jerky animations. Use transformX/transformY instead.

For height: 100% to work, all of the element's parents need to have the height proprty set. So in React this would include html, body, #root and possibly a couple of others. 
If you have trouble targeting some container divs, just write html, body, #root, #root > div

The default value of the align-items proerty in a flexbox is stretch

If you're using CSS modules and you want to add more than one class to an element, one way to do it is to put them in an arry and then use the join method:
	<button className={[styles.answerButton, styles.button].join(' ')}
Another is to use a template literal (can be done in a separate variable and you can add regular classnames alongside module ones):
    let deleteButton = `delete-unanswered ${styles.button} ${styles.deleteUnanswered}`


When setting multiple transform properties on an element, they must be on the same line otherwise the later one will cancel the previous ones. 

Inline styles always override external ones. 


Translate doesn't work on inline elements so you need to chagne them to inline-block.

If you've got a form and you want the elements stacked vertically (e.g. label, input and button), you could make the container a flexbox and then change it to a column but each element will
stretch across the page horizontally because the default value for align-items in a flexbox is 'stretch'. AN alternative is to make each element display block. This means they'll 
be on their own line but won't stretch across. 

If you apply a margin-top to en element and it seems to be applied to its parent element, add overflow: auto to the parent (this is something to do with collaspsing margins).

Imagine you have three child divs arranged horintally in a parent div (e.g. buttons in a nav bar). You want to give them some space so you apply padding to the parent. 
Now, you want the background color of the child components to change on hover. You'll see that the highlighted background color is surrounded by uncolored padding space. 
TO avoid this problem, instead of adding padding to the aprent, add height. The child elements will stretch to fill it (vertically) and so you'll have no problem with hover. 

The text inside buttons is centered veritcally and horizontally by default. So if you use them (with your own styling), they'll save you having to mess about trying to center text.


If justify-content: stretch doesn't work in a flex box, add flex-grow to items.

If you're using a Gogle font in React, iport it at the top of the main CSS file, not in head of html file/ 
